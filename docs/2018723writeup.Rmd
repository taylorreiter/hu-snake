---
title: "Hu Query Nbhds"
author: "Taylor Reiter"
date: "7/23/2018"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = FALSE, include = TRUE, eval = TRUE, warning = FALSE, error = FALSE, message = FALSE)
knitr::opts_knit$set(root.dir = normalizePath("../"))
```

```{r libraries}
library(Biostrings)
library(tidyverse)
library(ggthemes)
library(gridExtra)
library(grid)
library(png)
library(annotate)
library(Rsamtools)
library(rentrez)
library(knitr)
```

```{r notes}
#  notes about this document
# I recommend running the blast sections and outputting them to their respective files prior to knitting this document to.
# otherwise, NCBI queries will execute while knitting, and take a long time.
# BLAST path needs to be updated to proper path for executable
# the path to bin taxonomy information needs to be updated when this is integrated into the snakemake file.
#

```

## Background

Hu et al. 2016 undertook metagenomic analysis of microbial communities in oil reservoirs located in the Alaska North Slope. Methane production and carbon turnover (the return of carbon fixed by photosynthesis to atmospheric carbon dioxide) are two major biogeochemical transitions that occur in oil reservoirs. We focused our analysis on the Hu et al. SB1 sample, sampled from the Schrader Bluff Formation. Oil from this sample was the most degraded (i.e. relatively higher amount of small hydrocarbons) of all those sampled from the Alaska North Slope (Piceno et al. 2014), and the sample was not "soured" (via microbial hydrogen sulfide production).

## Methods overview

Of the 61 bins generated for sample SB1 by the Hu analysis, we performed queries that produced query neighborhoods with 30 bins. Twenty-two bins were binned from the SB1 sample, while eight were binned from the other Schrader Bluff sample, SB2, but were approximately 100% present in the SB1 sample. Each query neighborhood is composed of linear paths in the cDBG called unitigs. From each query neighborhood we subtracted the bin used to perform the query, producing a *unitig donuts*. Next we subtracted any sequence binned from any bin generated by the Hu analysis, producing *unitig crumbs*. 

Given than unitigs can be highly fragmented, we extracted any read from the metagenome sample that was composed of greater than or equal to 10% of k-mers found in the unitigs (i.e. if read of length 150 nucleotides contained greater than or equal to 15 k-mers that were contained in the unitigs, it was included). We assembled these reads to produce donut assemblies and crumb assemblies. 

We analyzed donut unitigs, crumb unitigs, donut assemblies, and crumb assemblies for functional and taxonomic content. We used prokka to find hypothetical protein coding domains in the unitigs and assemblies, and KEGG GhostKOALA for protein and taxonomic annotation.

## Results & Discussion

### The crumb assemblies make the most sense to analyze

```{r read_files}
donut_files <- list.files(path = "inputs/hu-s1_k31_r1_search_oh0_may20/", pattern = ".contigs.fa.gz.donut.fa$", full.names = T)
crumb_files <- list.files(path = "inputs/hu-s1_k31_r1_search_oh0_may20/", pattern = ".contigs.fa.gz.crumbs.fa$", full.names = T)
    
donuts <- lapply(donut_files, readDNAStringSet)
crumbs <- lapply(crumb_files, readDNAStringSet)
```    

There are small differences between donut unitigs and crumb unitigs.

```{r calc_uni}
crumb_uni_total <- rep(NA, length(crumbs))
donut_uni_total <- rep(NA, length(crumbs))
donut_uni_no_crumbs <- rep(NA, length(crumbs))
for(i in 1:length(crumbs)){
    crumb <- crumbs[[i]]
    donut <- donuts[[i]]
    crumb_uni_total[i] <- length(crumb)
    donut_uni_total[i] <- length(donut)
    donut_uni_no_crumbs[i] <- length(donut) - length(crumb)
}
```

```{r plot_uni}
# plot of total donut unitigs, colored by amount subtracted to make crumbs
unis <- as.data.frame(donut_uni_no_crumbs)
unis$crumb_uni_total  <- crumb_uni_total 
# label df rows
donut_files_small <- list.files(path = "inputs/hu-s1_k31_r1_search_oh0_may20/", pattern = ".contigs.fa.gz.donut.fa$")
names <- gsub(".fa.cdbg_ids.contigs.fa.gz.donut.fa", "", donut_files_small)
unis$bin <- names
unis <- gather(unis, key = uni_type, value = number, -bin)
uni_plot <- ggplot(unis, aes(x = bin, y = number, fill = uni_type)) + 
                  theme_pander() +
                  geom_bar(stat = "identity") +
                  theme(axis.text.x = element_text(angle = 45, hjust = 1)) +
                  ggtitle("Number of Unitigs in Donuts") +
                  xlab("Query Bin") +
                  ylab("Number of unitigs") +
                  labs(fill = "Donut Composition") +
                  scale_fill_hue(labels = c("Crumb & Donut", "Donut Only")) 
```

```{r calc_nucs}
# how many more nucleotides are there in the donut unitigs than in the crumbs unitigs?
crumb_nucs_total <- rep(NA, length(crumbs))
donut_nucs_total <- rep(NA, length(crumbs))
donut_nucs_no_crumbs <- rep(NA, length(crumbs))
for(i in 1:length(crumbs)){
    crumb <- crumbs[[i]]
    donut <- donuts[[i]]
    donut_nucs_total[i] <- sum(nchar(donut))
    crumb_nucs_total[i] <- sum(nchar(crumb))
    donut_nucs_no_crumbs[i] <- sum(nchar(donut)) - sum(nchar(donut[donut %in% crumb]))
  }
```

```{r plot_nucs}
# plot of total donut nucleotides, colored by amount subtracted to make crumbs
nucs <- as.data.frame(donut_nucs_no_crumbs)
nucs$crumb_nucs_total <- crumb_nucs_total
# label df rows
nucs$bin <- names
nucs <- gather(nucs, key = nuc_type, value = number, -bin)
nuc_plot <- ggplot(nucs, aes(x = bin, y = number, fill = nuc_type)) + 
                  theme_pander() +
                  geom_bar(stat = "identity") +
                  theme(axis.text.x = element_text(angle = 45, hjust = 1)) +
                  ggtitle("Number of Nucleotides in Donuts") +
                  xlab("Query Bin") +
                  ylab("Number of nucleotides (bp)") +
                  labs(fill = "Donut Composition") +
                  scale_fill_hue(labels = c("Crumb & Donut", "Donut Only")) 
```

```{r show_plots, include = TRUE, fig.height=3, fig.width=7}
uni_plot
nuc_plot
```

Both donut unitigs and crumbs unitigs are highly fragmented. Fragments are difficult to analyze because they give little biological signal, while longer nucleotide sequences give more biological signal. It therefore made more sense to analyze an assembly of the unitigs. 

```{r calc_histograms}
donuts_all <- do.call("c", donuts)
donuts_char <- as.data.frame(nchar(donuts_all))
donut_hist <- ggplot(donuts_char, aes(x = nchar(donuts_all))) + geom_histogram() +
  theme_pander() +
  scale_y_log10() +
  ylab("log10(count)") +
  xlab("length in nucleotides") +
  ggtitle("Length of unitigs in donuts")

crumbs_all <- do.call("c", crumbs)
crumbs_char <- as.data.frame(nchar(crumbs_all))
crumb_hist <- ggplot(crumbs_char, aes(x = nchar(crumbs_all))) + geom_histogram() +
  theme_pander() +
  scale_y_log10() +
  ylab("log10(count)") +
  xlab("length in nucleotides") +
  ggtitle("Length of unitigs in crumbs")
```

```{r plot_histograms, include = TRUE, fig.height=3, fig.width=7}
grid.arrange(donut_hist, crumb_hist, ncol = 2)
```

However, the small differences observed between the donuts and the crumbs led to large differences in the number of reads associated with donuts and with crumbs, and presumably the amount of sequence in the assemblies (I haven't tested this presumption yet, but can).

```{r calc_reads}
# Read in data
donut_reads_files <- list.files(path = "inputs/hu-s1_k31_r1_search_oh0_may20/", pattern = ".reads.fa.gz.donut.fa$", full.names = T)
crumb_reads_files <- list.files(path = "inputs/hu-s1_k31_r1_search_oh0_may20/", pattern = ".reads.fa.gz.crumbs.fa$", full.names = T)

donuts_reads <- lapply(donut_reads_files, readDNAStringSet)
crumbs_reads <- lapply(crumb_reads_files, readDNAStringSet)
    
# how many unitigs are subtracted from the donuts to produce the crumbs?
crumb_reads_total <- rep(NA, length(crumbs_reads))
donut_reads_total <- rep(NA, length(crumbs_reads))
donut_reads_no_crumbs <- rep(NA, length(crumbs_reads))
for(i in 1:length(crumbs_reads)){
    crumb <- crumbs_reads[[i]]
    donut <- donuts_reads[[i]]
    crumb_reads_total[i] <- length(crumb)
    donut_reads_total[i] <- length(donut)
    donut_reads_no_crumbs[i] <- length(donut) - length(crumb)
  }
```

```{r plot_reads}
# plot of total donut unitigs, colored by amount subtracted to make crumbs
reads <- as.data.frame(donut_reads_no_crumbs)
reads$crumb_reads_total  <- crumb_reads_total 
# label df rows
donut_reads_files2 <- list.files(path = "inputs/hu-s1_k31_r1_search_oh0_may20/", pattern = ".reads.fa.gz.donut.fa$")
names <- gsub(".fa.cdbg_ids.reads.fa.gz.donut.fa", "", donut_reads_files2)
reads$bin <- names
reads <- gather(reads, key = read_type, value = number, -bin)
plot_reads <- ggplot(reads, aes(x = bin, y = number, fill = read_type)) + 
      theme_pander() +
      geom_bar(stat = "identity") +
      theme(axis.text.x = element_text(angle = 45, hjust = 1)) +
      ggtitle("Number of Reads in Donuts") +
      xlab("Query Bin") +
      ylab("Number of Reads") +
      labs(fill = "Donut Composition") +
      scale_fill_hue(labels = c("Crumb & Donut", "Donut Only"))
```

```{r show_plot_reads, fig.height=3, fig.width=7}
plot_reads
```

I concluded that the crumb assemblies are the most conservative thing to analyze, and so this writeup focuses on them. 

### Taxonomic classification

We first sought to determine whether the taxonomic signal of the crumb assemblies was consistent with the Hu et al. taxonomic assignments of bins (queries). We did this by assessing the taxonomic signal of marker genes and all genes in the crumb assemblies. 

#### Marker Genes

Taxonomic classification can be performed using marker genes. Marker genes are conserved, single-copy sequences found in diverse organisms. Many marker genes have been sequenced which makes taxonomic classification via amino acid identity feasible. Marker genes are also used to estimate species abundance in a metagenome via read depth given that they are single-copy genes in genomes (see https://doi.org/10.1038/nmeth.2693). Some binning techniques take advantage of marker genes to co-segregate taxnomically similar sequences. 

Hu et al. used amino acid sequences of the marker genes *gyrA*, *gyrB*, and *recA* (bacteria only) to perform taxonomic assignment of bins. 

Some crumb assemblies contain marker genes (Table 1). We identified marker genes using the KEGG GhostKOALA algorithm on predicted amino acid sequences in the crumb assemblies. We explored taxonomy of the amino acid and nucleotide sequences of the marker genes using the blastp and blastn algorithms against the NCBI and nr/nt databases (7/27/18). This revealed the following:
1. Crumb assembly marker gene sequence taxonomic classification generally agrees with the Hu et al classification of queries.  
2. Marker gene sequences in the crumb assemblies are similar but not identical to marker gene sequences and the queries.  
3. In queries that lacked marker genes, marker genes in the crumb assemblies increase genome completeness.  

**Table 1**: Taxonomic marker genes identified in crumb assemblies from the Hu SB1 sample. *Note that because some queries were closely related to each other, some identical crumb assembly sequences are associated with two queries*

```{r read_crumb_kegg_anno}
# 1. Find gyrA, gyrB, and recA sequences in the crumb assemblies by parsing the KEGG GhostKoala output
# 2. write gyrA, gyrB, and recA nucleotide sequences to a fasta file
# 3. write gyrA, gyrB, and recA amino acid sequences to a fasta file
# 4. BLAST nucleotide sequences against NCBI 
# 5. BLAST amino acid sequences against NCBI
# 6. Report in a table. 

# read in crumb data
crumb_full <- list.files("outputs/hu-crumbs_bin/assembly/GhostKOALA/", "full.txt$", full.names = T)
crumb_kegg <- list.files("outputs/hu-crumbs_bin/assembly/GhostKOALA/", "full.txt$")

crumb_kegg <- gsub(".ko-ann-full.txt", "", crumb_kegg)
crumb_df <- data.frame(locus_tag = NA, geneID = NA, name = NA, score = NA, second = NA, second_score = NA, bin = NA)
for(i in 1:(length(crumb_full))){
  kegg <- read.csv(crumb_full[i], sep = "\t", stringsAsFactors = FALSE, na.strings = "",
                   col.names = c("locus_tag", "geneID", "name", "score", "second", "second_score", "bin")) 
  crumb_df <- rbind(crumb_df, kegg)
}

# add row specifying identity
crumb_df$origin <- rep("crumb", nrow(crumb_df))
```

```{r read_bin_kegg_anno}
# NEED TO UPDATE BIN DATA URL WHEN SNAKEMAKE OUTPUT IS CREATED
# read in bin data
bin_full <- list.files("sandbox/bin_plus_crumb_assembly/bin/", "full.txt$", full.names = T)
bin_full <- bin_full[2:31]
bin_kegg <- list.files("sandbox/bin_plus_crumb_assembly/bin/", "full.txt$")
bin_kegg <- bin_kegg[2:31]

bin_kegg <- gsub(".ko-ann-full.txt", "", bin_kegg)
bin_df <- data.frame(locus_tag = NA, geneID = NA, name = NA, score = NA, second = NA, second_score = NA, bin = NA)
for(i in 1:(length(bin_full))){
  kegg <- read.csv(bin_full[i], sep = "\t", stringsAsFactors = FALSE, na.strings = "",
                   col.names = c("locus_tag", "geneID", "name", "score", "second", "second_score", "bin")) 
  bin_df <- rbind(bin_df, kegg)
}

bin_df$origin <- rep("bin", nrow(bin_df))
```

```{r combine_kegg}
# combine two dfs
kegg_df <- rbind(crumb_df, bin_df)

# retain only kegg ids for which the score is > 100
kegg_df <- kegg_df[kegg_df$score > 100, ]
```

```{r find_crumb_marker_genes}
# define crumb marker KO
gyrA <- 'K02469'
gyrB <- 'K02470'
recA <- 'K03553'

crumb_marker <- kegg_df %>% 
                  filter(origin == "crumb") %>%
                  filter(geneID %in% c(gyrA, gyrB, recA))
```

```{r blast_crumb_marker_genes_nucs, include = FALSE}
indexFa("outputs/hu-crumbs_bin/assembly/prokka/all-assembly.ffn")   # create an index of file 'foo.fasta'
ffn = FaFile("outputs/hu-crumbs_bin/assembly/prokka/all-assembly.ffn")
gr = as(seqinfo(ffn), "GRanges")

get_nucs <- function(seq_name, GRanges, FaFile){
              idx = pmatch(seq_name, names(GRanges)) 
              seq = getSeq(FaFile, GRanges[idx])
              return(seq)
}

nucs <- lapply(X = crumb_marker[ , 1], FUN = function(x) get_nucs(seq_name = x, GRanges = gr, FaFile = ffn))

# https://support.bioconductor.org/p/86440/
blastf6 <- c('qseqid', 'sgi', 'sacc', 'pident', 'length', 'bitscore', 'evalue') # Fields for blast to return.

#  initiate empty data frame for for loop results.
blast_nuc <- data.frame('qseqid' = character(0),  'sgi' = character(0), 'sacc' = character(0), 'pident' = numeric(0), 'length' = numeric(0), 'bitscore' = numeric(0), 'evalue' = numeric(0), 'query' = character(0))

for(i in 1:length(nucs)){
  if(file.exists("blast_nuc.csv")){
   next #  if file exists do not run for loop.
  }
  
  #  run blast via the command line but save STD out to object to blastout.
  blastout <- system2('/Users/taylorreiter/miniconda3/envs/sandbox/bin/blastn',
                    c('-db', "'nt'", '-outfmt', sprintf('"6 %s"', paste(collapse=' ', blastf6)),
                      '-remote', '-word_size', "'11'", '-gapopen', "'5'", '-gapextend', "'2'", '-reward',
                      "'2'", '-penalty', "'-3'", '-max_target_seqs', "'10'"),
                    input = as.character(nucs[[i]][1]), stdout = TRUE)
                    # run blast in from the command line.
                    # input sequences in vector nucs.
                    # Write to STD out as  character vector.
  
  # parse blastout as a table and assign names to it
  blastdf <- `names<-`(read.table(quote="", sep='\t', textConnection(blastout)), blastf6)
  # add query name to blastdf
  blastdf$query <- rep(names(nucs[[i]]), nrow(blastdf))
  blast_nuc <- rbind(blast_nuc, blastdf)
}

# if file doesn't exist, write to doc to avoid costly NCBI queries.
if(!file.exists("blast_nuc.csv")) {
  write.csv(blast_nuc, "blast_nuc.csv", quote = F, row.names = F)
} else {
  blast_nuc <- read.csv("blast_nuc.csv")
}
```

```{r parse_nuc_rentrez}
block <- function(i){
          nuid_species <- entrez_summary(db="nucleotide", id = i)
          Sys.sleep(2) # sleep; don't overwhelm NCBI server
          return(nuid_species)
}

# apply to all unique nuids
nuid_names <- lapply(unique(blast_nuc$sacc), block)
# extract species names from retrieved data
nuid_species <- sapply(nuid_names, "[[", 26)
# make a dataframe of nuid and species
nuid_df <- as.data.frame(unique(as.character(blast_nuc$sacc)))
nuid_df$species <- nuid_species

# merge dataframe with nuid species
blast_nuc <- merge(blast_nuc, nuid_df, by.x = "sacc", by.y = "unique(as.character(blast_nuc$sacc))")

# retain only best blast hit
blast_nuc <- blast_nuc[order(blast_nuc$query, blast_nuc$bitscore), ]
# Select the last row by id
blast_nuc <- blast_nuc[!duplicated(blast_nuc$query, fromLast=TRUE), ]

# merge with hu-info
info <- read.csv("sandbox/hu_info.csv")

# parse blast queries to bin name
blast_nuc$name <- gsub("(ass_)([0-9]{5})", "", blast_nuc$query)
info_blast <- left_join(blast_nuc, info, by = "name")
```

```{r blast_crumb_marker_genes_aas, include = FALSE}
indexFa("outputs/hu-crumbs_bin/assembly/prokka/all-assembly.faa") 
faa = FaFile("outputs/hu-crumbs_bin/assembly/prokka/all-assembly.faa")
graa = as(seqinfo(faa), "GRanges") 

get_aas <- function(seq_name, GRanges, FaFile){
              idxaa = pmatch(seq_name, names(GRanges)) 
              seqaa = getSeq(FaFile, GRanges[idxaa], as="AAStringSet") 
              return(seqaa)
}

aas <- lapply(X = crumb_marker[ , 1], 
              FUN = function(x) get_aas(seq_name = x, GRanges = graa, FaFile = faa))

blast_aas <- data.frame('qseqid' = character(0),  'sgi' = character(0), 'sacc' = character(0), 'pident' = numeric(0), 'length' = numeric(0), 'bitscore' = numeric(0), 'evalue' = numeric(0), 'query' = character(0))

for(i in 1:length(aas)){
  if(file.exists("blast_aa.csv")){
   next
  }
  print(i)
  blastoutaa <- system2('/Users/taylorreiter/miniconda3/envs/sandbox/bin/blastp',
                    c('-db', "'nr'", '-outfmt', sprintf('"6 %s"', paste(collapse=' ', blastf6)),
                      '-remote', '-word_size', "'6'", '-gapopen', "'11'", '-gapextend', "'1'", '-window_size',
                      "'40'", '-matrix', "'BLOSUM62'", '-comp_based_stats', '"2"', '-max_target_seqs', "'10'"),
                    input = as.character(aas[[i]][1]), stdout = TRUE)
  
  blastdfaa <- `names<-`(read.table(quote="", sep='\t', textConnection(blastoutaa)), blastf6)
  blastdfaa$query <- rep(names(aas[[i]]), nrow(blastdfaa))
  blast_aas <- rbind(blast_aas, blastdfaa)
}

if(!file.exists("blast_aa.csv")) {
  write.csv(blast_aas, "blast_aa.csv", quote = F, row.names = F)
} else {
  blast_aas <- read.csv("blast_aa.csv")
}
```

```{r parse_aa_rentrez}
block2 <- function(i){
          pid_species <- entrez_summary(db="protein", id = i)
          Sys.sleep(2) # sleep; don't overwhelm NCBI server
          return(pid_species)
}

# apply to all unique nuids
pid_names <- lapply(unique(blast_aas$sacc), block2)
# extract species names from retrieved data
pid_species <- sapply(pid_names, "[[", 26)
# make a dataframe of nuid and species
pid_df <- as.data.frame(unique(as.character(blast_aas$sacc)))
pid_df$species <- pid_species

# merge dataframe with nuid species
blast_aas <- merge(blast_aas, pid_df, by.x = "sacc", by.y = "unique(as.character(blast_aas$sacc))")

# retain only best blast hit
blast_aas <- blast_aas[order(blast_aas$query, blast_aas$bitscore), ]
# Select the last row by id
blast_aas <- blast_aas[!duplicated(blast_aas$query, fromLast=TRUE), ]
# modify column names to distinguish aa from nuc.
colnames(blast_aas)[c(1:7, 9)] <- paste0(colnames(blast_aas)[c(1:7, 9)], "_aa")
colnames(blast_aas)[8] <- 'query'
colnames(blast_aas) <- c("sacc_aa","qseqid_aa", "sgi_aa","pident_aa","length_aa","bitscore_aa", "evalue_aa",   "query","species_aa" )
# parse blast queries to bin name
info_blast <- left_join(blast_aas, info_blast, by = "query")
```

```{r display_marker_gene_table}
# join with marker gene info
crumb_marker$gene <- gsub("(; DNA gyrase subunit )([AB])( \\[EC:5.99.1.3\\])", "", crumb_marker$name)
info_blast <- left_join(info_blast, crumb_marker, by = c("query" = "locus_tag"))
info_blast_small <- info_blast[ , c(1, 4:10, 13:17, 20, 55, 50)]
info_blast_small <- info_blast_small[ , c(14, 6, 15:16, 7, 1:5,13, 8:12)]
colnames(info_blast_small) <- c("hu_taxonomy", "crumb_assembly", "marker_gene", "gk_score", "AA_species", "AA_accession", "AA_pident", "AA_length", "AA_bitscore", "AA_evalue", "N_species", "N_accession", "N_pident", "N_length", "N_bitscore", "N_evalue")
kable(info_blast_small)
```

The crumb assembly marker gene sequence taxonomic classification generally agrees with the Hu et al classification of queries. At the amino acid level, the genus-level classification was always in agreeance with the Hu et al classification. However, often times the best match was to a marker gene sequence binned by Hu et al (see next paragraph). At the nucleotide level, the taxonomic classification of the crumb assemblies matched the Hu et al taxonomic assignments when the percent identity was above 85%. Matches below this percent identity threshold were candidate phyla (*Marinimicrobia bacterium* 46_43 and *Parcubacteria bacterium* 33_209). Candidate phlya are organisms for which no cultured isolates exist, but for which sequencing evidence supports their inclusion in different phlya than known organisms. The low percent identity (~60%) of marker genes in the query neighborhoods to other known organisms supports their classification as candidate phyla. 

The nr/nt database includes our query sequences because the Hu et al bins were deposited in GenBank. Our BLAST search therefore also checked whether the crumb assembly marker gene sequences were similar at the amino acid or nucleotide level to sequences in the Hu bins. Eight of 14 crumb assembly marker gene sequences matched most closely to a query amino acid sequence. However, percent identity ranged from 89.565% - 97.101%, indicating that the sequences are closely related to but different from those found in the queries. These sequences likely arise from strains in the metagenome. At the nucleotide level, no crumb assembly marker gene sequences matched most closely to query nucleotide sequencing, further demonstrating that the sequences recovered in the crumb assemblies are taxonomically similar to but different from the query sequences. These results support the liklihood that there are more strains present in the crumb assemblies than are represented in the queries. 

In queries that lacked marker genes, marker genes in the crumb assemblies increase genome completeness. Queries *Methanoculleus marisnigri* isolate 63_41 (hu-genome02), *Methanoculleus marisnigri* isolate 62_101 (hu-genome30), and *Marinimicrobia bacterium 46_47* (hu-genome35) each contained a *gyrA* sequence. However the six other *gyrA* sequences and seven *gyrB* sequences observed in the crumb assemblies increased completeness of the query by associating these sequences with other sequences in the query. These new associations could be especially useful for taxonomic placement of *Parcubacteria bacterium* 33_209 (hu-genome38), a near complete genome belonging to a candidate phyla.

#### Taxonomic signal from non-marker genes

We also investigated the taxonomic signal of non-marker genes by using the GhostKOALA algorithm on predicted proteins in the crumb assemblies. We noted three trends:
1. The taxonomic signal from archaeal crumb assemblies is accurate and consistent for predicted genes.  
2. The taxonomic signal for predicted genes in bacterial crumb assemblies did not agree with all query assignments.
3. The taxonomic signal is clear at the kingdom level for predicted genes in crumb assemblies of candidate phyla.  

For archaeal queries, the majority of genes were annotated at the correct genus level (**figure 1**). There were a handful of genes in each crumb assembly that were annotated as a different genus of methanogenic archaea or as bacteria. Closer inspection of the bacterial annotations revealed that although there was no strong match in KEGG, archaeal sequence was a better match than bacterial sequence when BLASTed against RefSeq. This may reflect horizontal gene transfer, however we did not investigate this hypothesis further (e.g. via site rate heterogeneity tests). 

```{r fig1, fig.width = 7, fig.height=3}
img <- readPNG("docs/figures/hu-genome02.png")
grid.raster(img)
```

**Figure 1:** An example of the taxonomic signal from the amino acid sequences of predicted genes in the crumb assembly of *Methanoculleus marisnigri* isolate 63_41 (hu-genome02). We performed taxonomic classification with KEGG GhostKOALA.

For bacterial queries, the taxonomic signal of non-marker genes did not agree with the all query assignments. For example, the taxonomic signal matched at the family level for queries hu-genome14, hu-genome29, and hu-genome36 (all assigned as *Desulfotomaculum*). The second most abundant annotation for predicted genes in the crumb assemblies matched the *Desulfotomaculum*, but *Pelotomaculum* was the best match (**figure 2**). *Desulfotomaculum* and *Pelotomaculum* are in the same family, *Peptococcaceae*. 

```{r fig2, fig.width = 7, fig.height=3}
img <- readPNG("docs/figures/hu-genome29.png")
grid.raster(img)
```

**Figure 2:** An example of the taxonomic signal from the amino acid sequences of predicted genes in the crumb assembly of *Desulfotomaculum sp.* (hu-genome29). The most abundant prediction was for genus *Pelotomaculum*. We performed taxonomic classification with KEGG GhostKOALA.

There was disagreement between the taxonomic assignment of queries hu-genome25 and hu-genome40 and the taxonomic signal of predicted proteins in the crumb assemblies. These queries were assigned as class *Anaerolineae*, however a genus within this class was the second most abundant taxonomic annotation. The most abundant was *Brevibacterium*, which is in a different phylum than *Anaerolineae* (*Actinobacteria* vs. *Chloroflexi*). 

Interestingly, the queries hu-genome03, hu-genome12, hu-genome31, and hu-genome33 were assigned to the order *Synergistales*, however all four had strong matches to the genus *Thermovirga*, a genus within order *Synergistales*. 

Lastly, we observed that the taxonomic signal is clear at the kingdom level for predicted genes in crumb assemblies of queries assigned to candidate phyla. This was true for queries hu-genome10, hu-genome13, hu-genome21, hu-genome27, hu-genome28, hu-genome34, hu-genome35, hu-genome37, and hu-genome38, all of which were candidate phyla (**figure 3**). No candidate phyla had a strong taxonomic signal, supporting their assignment into new taxonomic classifications. We observed a similar weak taxonomic signal for queries hu-genome23 and hu-genome39 which were not candidate phyla. 

```{r fig3, fig.width = 7, fig.height=3}
img <- readPNG("docs/figures/hu-genome34.png")
grid.raster(img)
```

**Figure 3:** An example of the taxonomic signal from the amino acid sequences of predicted genes hu-genome34 crumb assembly. hu-genome34 bin was classed as *Atribacteria bacterium*, a candidate phlya. We performed taxonomic classification with KEGG GhostKOALA.

These results support that the taxonomy of predicted proteins in the crumb assemblies loosely matches that of the queries. Taxonomic inconsistencies could result from incomplete databases (KEGG), horizontal gene transfer, and from the novel nature of these sequencies (i.e. some of these sequences might not closely resemble anything that has been sequenced before, and thus taxonomic classification of non-marker genes is a difficult problem.)

### Functional characterization

#### Crumb assemblies increase functional content associated with queries

The crumb assemblies increased functional content associated with the queries by 11% (**figure 4**). The queries collectively contained 29,897 in annotated proteins, while the crumb assemblies contained 3,412 annotated proteins. No annotated protein in any crumb assembly occurred in a BRITE hierarchy that was not represented in the query, meaning that we recover genes from pathways that are already represented in the queries.

The crumb assemblies do not contain an even distribution of annotated proteins. *Methanoculleus marisnigri* isolate 63_41 (hu-genome02) had 475 annotated proteins, while *Microgenomates bacterium* 39_7 (hu-genome19) and Candidate division *TA06 bacterium* 32_111 (hu-genome37) had none. Because confident annotations rely on the KEGG database, it is possible that no predicted proteins were annotated for these latter two genomes given that they belong to candidate phlya.

```{r fig4, fig.width = 6, fig.height=7}
img <- readPNG("docs/figures/bin-crumb-assembly-function2.png")
grid.raster(img)
```

**Figure 4:** KEGG ortholog BRITE hierarchy categories for prokka-predicted, GhostKOALA annotated proteins in the crumb assemblies and in the queries (bins). Cut off score 100.

#### Crumb assemblies contain predicted genes with biologically important roles

Bacteria and archaea seem to contribute approximately equal amounts of functional content from crumb assemblies (**figure 5**). Carbon metabolism was the second most abundant BRITE hierarchy category, which further supports the degraded state of this reservoir, as reported by Piceno et al. 2014.   

```{r fig5, fig.width = 6, fig.height=7}
img <- readPNG("docs/figures/kegg-all-col-kingdom.png")
grid.raster(img)
```

**Figure 5:** KEGG ortholog BRITE hierarchy categories for prokka-predicted, GhostKOALA annotated proteins in the crumb assemblies. Cut off score 100.


There are also predicted genes that are important to the biology of the oil reservoir. Methane production and carbon degradation are important in oil reservoirs, and these are abundantly predicted in the crumb assemblies (**figure 6**).

```{r fig6, fig.width = 4, fig.height=3}
img <- readPNG("docs/figures/an_ass.png")
grid.raster(img)
```

**Figure 6:** Presence of biologically important genes, as defined in An et al. 2013. Methanogenic processes were most abundant, while dearomatization processes were second. All processes were anaerobic.

#### Nitrogenase genes

Our approach also built upon observations of nitrogenase genes identified by Hu et al. We observed five additional nitrogenase gene sequences coding for portions of *nifH*, *glnB*, and *nifE*. All are located in crumb assemblies of queries previously identified as containing nitrogen fixation genes. Both *Methanocalculus sp. 52_23* (hu-genome24) and *Methanoculleus marisnigri* (hu-genome02/30) contained a first observation of *glnB*, a nitrogen metabolism regulatory protein not previously observed in the SB1 sample but observed in a methanogenic archaea from the K3 sample. These observations support the Hu et al. conclusion that the majority of nitrogen fixation genes occur in methanogenic *Archaea* as opposed to *Bacteria*, in contrast to most other ecosystems. 

**Table 2**

|query bin | organism | Crumb N. F.\* gene(s) | gk score | Bin id'd N. F. genes |
|----------|----------|-----------------------|-------|----------------------|
|hu-genome30 | Methanoculleus marisnigri 62_101 | *glnB*\** | 134 | *nifH*, *nifK*|
|hu-genome02 | Methanoculleus marisnigri 63_41 | *glnB*  | 134 | *nifH*, *nifK*|
|hu-genome02 | Methanoculleus marisnigri 63_41 | *nifH* | 340 | *nifH*, *nifK*|
|hu-genome24 | Methanocalculus sp. 52_23 | *glnB*  | 129 | *nifH*, *nifK*|
|hu-genome29 | Desulfotomaculum sp. 46_80 | *nifE* | 114 | *nifH*, *nifK*, *nifE*, *nifB*|
|hu-genome41 | Methanosaeta harundinacea 57_489 | *nifH* | 154 |  *nifH*, *nifE*|
*N. F. = Nitrogen Fixation
** overlap in crumbs, same observation as *glnB* in hu-genome02 crumbs.

#### Crumbs might be enriched for metabolic genes

We performed a KEGG enrichment analysis on the genes found in the crumb assemblies. Only metabolic genes were significantly enriched for, with the exception of Ribosomal genes (**figure 7**). This contrasts to "informational" genes which are involved in replication, translation, and transcription of nucleotides. This may indicate that we recover more accessory genes, i.e. genes in the pangenome, instead of core genes in the crumb assemblies. Still working on testing this. If this is true, it is interesting because it demonstrates a source of systemic bias in metagenomic assembly/binning. 

```{r fig7, fig.width = 4, fig.height=3}
img <- readPNG("docs/figures/crumb-dotplot-score100.png")
grid.raster(img)
```

**Figure 7:** KEGG enrichment analysis of genes found in the crumb assemblies confidently annotated by KEGG GhostKOALA (>= 100). Carbon metabolism and methane metabolism are important for biogeochemical transformations in oil reservoirs.




```{r deprecated, eval = FALSE}
# BLAST with annotate --------
# nuc_matches <- lapply(X = nucs, FUN = function(x) blastSequences(x = x, database = "nt", hitListSize = 10, program = "blastn",
# timeout=120, as = "data.frame"))
# 
# # prune Data frame to relevant results.
# nuc_pruned <- list()
# for(i in 1:length(nuc_matches)){
#   p <- nuc_matches[[i]][ , c(4, 7:15)]
#   p$query <- crumb_marker[i, 1]
#   nuc_pruned[[i]] <- p
# }
# 
# nuc_pruned <- do.call(rbind, nuc_pruned)

# BLAST ------------------------
# Make it faster by combining all queries into one file and sending off only once. This excedes CPU usage limit.
#
# nucs_combined <- vector()
# for(i in 1:length(nucs)){
#   seq <- nucs[[i]][1]
#   nucs_combined[i] <- seq
# }
#
# blastout2 <- system2('/Users/taylorreiter/miniconda3/envs/sandbox/bin/blastn', 
#                     c('-db', "'nt'", '-outfmt', sprintf('"6 %s"', paste(collapse=' ', blastf6)), 
#                       '-remote', '-word_size', "'11'", '-gapopen', "'5'", '-gapextend', "'2'", '-reward',
#                       "'2'", '-penalty', "'-3'", '-max_target_seqs', "'10'"), 
#                     input = nucs_combined, stdout = TRUE)
#                     # run blast in from the command line. 
#                     # input sequences in vector nucs. 
#                     # Write to STD out as  character vector.
# 
# blastdf2 <- `names<-`(read.table(quote="", sep='\t', textConnection(blastout)), blastf6) 
```

